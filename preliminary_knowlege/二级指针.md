## C/C++什么时候使用二级指针

`总结:`

* 如果想修改指针指向变量的值，则无需传入高一级指针，使用同级指针即可；
* 如果想要修改指针本身的值，也就是地址，则应使用比原指针高一级的指针来实现


### int类型做函数参数
~~~c
#include<iostream>
using namespace std;

void func_1(int a) {
    /* 临时变量a的值从1被修改为10，这都与外部变量a没有任何关系，这便是按值传递 */
    a = 10;
}

int main() {
    int a = 1;
    func_1(a);
    cout << a << endl;
    return 0;
}
~~~
说明：函数会自己创建一个临时变量 ==> 然后将函数传进来的值赋给临时变量，所以我们修改函数里所谓的a只是一个临时变量，并不是修改的函数外的a.

### 一级指针做参数
~~~c
void func_2(int* a) {
    *a = 10;
    /*
     函数接受一个值，这个值是地址，谁的地*址？外部变量a的地址，同样的套路，函数创建一个临时变量（指针类型）来存储外部变量a的地址；在函数内部使用临时变量a可得到外部变量a的地址，使*a可以获取外部变量a地址中所存储的值；这个临时变量a复制的是外部变量的地址，按值传递，无论怎么复制，地址是唯一的，通过地址来修改外部变量的值是可以实现的。
    */
}
~~~

一级指针解决不了的问题：
~~~c
void func_2(int* a) {
    /* 想让指针指向空（或者一个新的地址） */
    a = NULL;
}

int main() {
    int a = 10;
    int *b = &a; /* b存储的是变量a的地址 */
    func_2(b);
}

/**
 * 不能修改的原因：
 * 老样子，函数创建临时变量a存储b的值，也就是变量a的地址，
 * 给变量a赋值为空，结果只是临时变量a被修改了值，而原外部变量b的* 值还是指向外部变量a的地址，所以该函数实现不了预期的功能。
*/
~~~

### 二级指针做参数
~~~c
void func_3(int** a) {
    *a = NULL;
}

int main() {
    int a = 10;
    int* b = &a;
    func_3(&b);
    return 0;
}

/* 函数创建临时变量a来存储b的地址，*a是外部变量b的地址，所以可以成功*/
~~~  

参考来源：[C/C++什么时候使用二级指针，你知道吗?](https://blog.csdn.net/Fdog_/article/details/105583725)

## cJSON中`cJSON_ParseWithOpts`使用二级指针的原因

`其想做到的目标其实就是改变指针的指向`